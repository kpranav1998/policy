Function Flatten-Object {                                      
    [CmdletBinding()]Param (
        [Parameter(ValueFromPipeLine = $True)][Object[]]$Objects,
        [String]$Separator = ".", [ValidateSet("", 0, 1)]$Base = 1, [Int]$Depth = 5, [Int]$Uncut = 1,
        [String[]]$ToString = ([String], [DateTime], [TimeSpan]), [String[]]$Path = @()
    )
    $PipeLine = $Input | ForEach {$_}; If ($PipeLine) {$Objects = $PipeLine}
    If (@(Get-PSCallStack)[1].Command -eq $MyInvocation.MyCommand.Name -or @(Get-PSCallStack)[1].Command -eq "<position>") {
        $Object = @($Objects)[0]; $Iterate = New-Object System.Collections.Specialized.OrderedDictionary
        If ($ToString | Where {$Object -is $_}) {$Object = $Object.ToString()}
        ElseIf ($Depth) {$Depth--
            If ($Object.GetEnumerator.OverloadDefinitions -match "[\W]IDictionaryEnumerator[\W]") {
                $Iterate = $Object
            } ElseIf ($Object.GetEnumerator.OverloadDefinitions -match "[\W]IEnumerator[\W]") {
                $Object.GetEnumerator() | ForEach -Begin {$i = $Base} {$Iterate.($i) = $_; $i += 1}
            } Else {
                $Names = If ($Uncut) {$Uncut--} Else {$Object.PSStandardMembers.DefaultDisplayPropertySet.ReferencedPropertyNames}
                If (!$Names) {$Names = $Object.PSObject.Properties | Where {$_.IsGettable} | Select -Expand Name}
                If ($Names) {$Names | ForEach {$Iterate.$_ = $Object.$_}}
            }
        }
        If (@($Iterate.Keys).Count) {
            $Iterate.Keys | ForEach {
                Flatten-Object @(,$Iterate.$_) $Separator $Base $Depth $Uncut $ToString ($Path + $_)
            }
        }  Else {$Property.(($Path | Where {$_}) -Join $Separator) = $Object}
    } ElseIf ($Objects -ne $Null) {
        @($Objects) | ForEach -Begin {$Output = @(); $Names = @()} {
            New-Variable -Force -Option AllScope -Name Property -Value (New-Object System.Collections.Specialized.OrderedDictionary)
            Flatten-Object @(,$_) $Separator $Base $Depth $Uncut $ToString $Path
            $Output += New-Object PSObject -Property $Property
            $Names += $Output[-1].PSObject.Properties | Select -Expand Name
        }
        $Output | Select ([String[]]($Names | Select -Unique))
    }
}; Set-Alias Flatten Flatten-Object



function RunARGquery {
    param (
        [string[]]$SubscriptionIds,
        [string]$ARG_query
    )
    
    $fullResultSet = @()
    $pageSize = 1000
    
    # Subscription batching code below taken
    #  from https://docs.microsoft.com/en-us/azure/governance/resource-graph/troubleshoot/general#toomanysubscription
    # Create a counter, set the batch size, and prepare a variable for the results
    $counter = [PSCustomObject] @{ Value = 0 }
    $batchSize = 1000
    # Group the subscriptions into batches
    $subscriptionsBatch = $subscriptionIds | Group –Property { [math]::Floor($counter.Value++ / $batchSize) }

    $currentBatchNo = 0
    # Run the query for each batch
    foreach ($batch in $subscriptionsBatch) {
        $pagesProcessedSoFar = 0
        do {
            $results = @()
            if($pagesProcessedSoFar -eq 0) {
                $results = Search-AzGraph –Subscription $batch.Group –Query $ARG_query –First $pageSize
		
            }
            else {
                $results = Search-AzGraph –Subscription $batch.Group –Query $ARG_query –First $pageSize –Skip ($pagesProcessedSoFar * $pageSize)
		
            }
            $pagesProcessedSoFar++
            Write-Host "Processed $pagesProcessedSoFar pages so far. A number of $(($results | Measure-Object).count) results returned in the last page"
            $fullResultSet += $results
        } while(($results | Measure-Object).count -eq $pageSize)
        Write-Host "Finished subscription batch $currentBatchNo"
        $currentBatchNo++
    }
    return $fullResultSet
}

Write-Host "Getting list of Azure subscriptions…"
# Fetch the full array of subscription IDs
$subscriptions = Get-AzSubscription
$subscriptionIds = $subscriptions.Id
Write-Host "Found $(($subscriptionIds | Measure-Object).count) subscriptions"


$ARM_ARG_query = @"
Resources
    | where type =~ 'microsoft.compute/virtualmachines'
"@
Write-Host "Running ARM ARG query…"
$data = RunARGquery –SubscriptionIds $subscriptionIds –ARG_query $ARM_ARG_query | Select-Object -Property Data

$flat_results = $results.Data | Flatten-Object
$flat_results  = @()

foreach ($element in $data.data) 
{ $element = $element | Flatten-Object
$flat_results  += $element 

 }




$flat_results  |  Export-Csv –NoTypeInformation "./test.csv"
